Rustの **ジェネリクス（Generics）** とは、一言でいうと **「型を引数として受け取る仕組み」** のことです。
特定の型（`i32` や `String` など）に縛られず、 **「どんな型でも受け取れるが、一度決めたらその型として厳格に扱う」** ような抽象的なコードを書くために使われます。


## なぜジェネリクスが必要なのか？

例えば、「2つの値を受け取って、それを保持する構造体」を作りたいとします。ジェネリクスがない場合、型ごとに構造体を作る必要があります。

* `i32` 用の構造体
* `f64` 用の構造体
* `String` 用の構造体...

これではコードが重複してしまいます。ジェネリクスを使えば、これらを1つにまとめられます。

## ジェネリクスの基本構文

慣習として、ジェネリックな型引数には **`T`** (Typeの略) という一文字がよく使われます。山括弧 `<T>` を使って定義します。

### 構造体での使用例

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    // T が i32 として扱われる
    let integer_point = Point { x: 5, y: 10 };

    // T が f64 として扱われる
    let float_point = Point { x: 1.0, y: 4.0 };
}

```

### 関数での使用例

```rust
// どんな型 T の引数でも受け取って、そのまま返す関数
fn identity<T>(item: T) -> T {
    item
}

```

## ジェネリクスの特徴

__① ゼロコスト抽象化__

Rustのジェネリクスは、コンパイル時に **「単一化（Monomorphization）」** という処理が行われます。
コンパイラが、実際に使われている型（`i32`用、`f64`用など）ごとに具体的なコードを自動生成するため、実行時のパフォーマンス低下（オーバーヘッド）が全くありません。

__② 型の安全性__

「何でも入れられる型（例えば他言語の `Object` 型など）」とは違い、ジェネリクスはコンパイル時に型が決定されます。そのため、型が混ざることで発生するバグを未然に防げます。


### トレイト境界

「どんな型でもOK」だと、逆に何も操作ができなくて不便なことがあります。例えば「2つの値を足し算するジェネリック関数」を作ろうとしても、すべての型が足し算できるわけではないからです。

そこで、 **「このトレイトを実装している型ならOK」という制限をかけることができます。これをトレイト境界** と呼びます。

```rust
// 比較可能 (PartialOrd) な型 T しか受け付けない関数
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest { // PartialOrd があるから比較できる！
            largest = item;
        }
    }
    largest
}

```

### まとめ

* **ジェネリクス**: 具体的ではない「抽象的な型」を使ってコードを書く仕組み。
* **メリット**: コードの再利用性が高まり、かつ実行速度も速い。
* **使い所**: 複数の型で同じロジックを使いたいとき（`Vec<T>` や `Option<T>` など）。


## ユースケース

ジェネリクスが真価を発揮するのは、 **「ロジック（処理の流れ）は同じなのに、扱うデータの型だけが違う」** という場面です。

具体的に有効な3つのケースを紹介します。

### 1. 汎用的なコレクション（入れ物）を作るとき

これが最も一般的な用途です。Rust標準ライブラリの `Vec<T>`（ベクタ）や `HashMap<K, V>` がその筆頭です。

* **有効な理由**:
「数値のリスト」「文字列のリスト」「自分で作った構造体のリスト」……これらは「データを順番に並べて保持する」というロジックは全く同じです。
ジェネリクスのおかげで、私たちは型ごとに異なるリスト（`IntegerVec`, `StringVec`など）を自作する必要がありません。

### 2. 「有無」や「成功・失敗」などの共通パターンを扱うとき

Rustの `Option<T>` や `Result<T, E>` がこれに当たります。

* **有効な理由**:
「値があるかもしれないし、ないかもしれない」という概念は、数値だろうがユーザーデータだろうが共通しています。
`Option<T>` と定義することで、 **「中身が何であれ、安全に取り出す」** ためのメソッド（`.unwrap()` や `.is_some()` など）をあらゆる型に対して共通して提供できます。


### 3. アルゴリズムを抽象化するとき

「最大値を求める」「並び替える」「平均を出す」といった計算アルゴリズムを実装するときです。

* **有効な理由**:
例えば「2つの値のうち大きい方を返す」関数を作るとき、ジェネリクスを使えば整数 (`i32`)、浮動小数点 (`f64`)、さらには「日付」や「名前の長さ」など、**比較可能なものであれば何にでも**同じ関数を適用できます。


### 逆に、いつ使わないべきか？

ジェネリクスは強力ですが、 **「その型固有の機能」をガッツリ使う場合** は、ジェネリクスを使わずに具体的な型で書く方がシンプルです。

* **具体例**: 「特定の構造体の中にある特定のフィールドを書き換える」だけの関数なら、ジェネリクスにする必要はありません。






Rustの **ジェネリクス（Generics）** とは、一言でいうと **「型を引数として受け取る仕組み」** のことです。
特定の型（`i32` や `String` など）に縛られず、 **「どんな型でも受け取れるが、一度決めたらその型として厳格に扱う」** ような抽象的なコードを書くために使われます。


## なぜジェネリクスが必要なのか？

例えば、「2つの値を受け取って、それを保持する構造体」を作りたいとします。ジェネリクスがない場合、型ごとに構造体を作る必要があります。

* `i32` 用の構造体
* `f64` 用の構造体
* `String` 用の構造体...

これではコードが重複してしまいます。ジェネリクスを使えば、これらを1つにまとめられます。

## ジェネリクスの基本構文

慣習として、ジェネリックな型引数には **`T`** (Typeの略) という一文字がよく使われます。山括弧 `<T>` を使って定義します。

### 構造体での使用例

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    // T が i32 として扱われる
    let integer_point = Point { x: 5, y: 10 };

    // T が f64 として扱われる
    let float_point = Point { x: 1.0, y: 4.0 };
}

```

### 関数での使用例

```rust
// どんな型 T の引数でも受け取って、そのまま返す関数
fn identity<T>(item: T) -> T {
    item
}

```

## ジェネリクスの特徴

__① ゼロコスト抽象化__

Rustのジェネリクスは、コンパイル時に **「単一化（Monomorphization）」** という処理が行われます。
コンパイラが、実際に使われている型（`i32`用、`f64`用など）ごとに具体的なコードを自動生成するため、実行時のパフォーマンス低下（オーバーヘッド）が全くありません。

__② 型の安全性__

「何でも入れられる型（例えば他言語の `Object` 型など）」とは違い、ジェネリクスはコンパイル時に型が決定されます。そのため、型が混ざることで発生するバグを未然に防げます。


### トレイト境界

「どんな型でもOK」だと、逆に何も操作ができなくて不便なことがあります。例えば「2つの値を足し算するジェネリック関数」を作ろうとしても、すべての型が足し算できるわけではないからです。

そこで、 **「このトレイトを実装している型ならOK」という制限をかけることができます。これをトレイト境界** と呼びます。

```rust
// 比較可能 (PartialOrd) な型 T しか受け付けない関数
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest { // PartialOrd があるから比較できる！
            largest = item;
        }
    }
    largest
}

```

### まとめ

* **ジェネリクス**: 具体的ではない「抽象的な型」を使ってコードを書く仕組み。
* **メリット**: コードの再利用性が高まり、かつ実行速度も速い。
* **使い所**: 複数の型で同じロジックを使いたいとき（`Vec<T>` や `Option<T>` など）。


## ユースケース

ジェネリクスが真価を発揮するのは、 **「ロジック（処理の流れ）は同じなのに、扱うデータの型だけが違う」** という場面です。

具体的に有効な3つのケースを紹介します。

### 1. 汎用的なコレクション（入れ物）を作るとき

これが最も一般的な用途です。Rust標準ライブラリの `Vec<T>`（ベクタ）や `HashMap<K, V>` がその筆頭です。

* **有効な理由**:
「数値のリスト」「文字列のリスト」「自分で作った構造体のリスト」……これらは「データを順番に並べて保持する」というロジックは全く同じです。
ジェネリクスのおかげで、私たちは型ごとに異なるリスト（`IntegerVec`, `StringVec`など）を自作する必要がありません。

### 2. 「有無」や「成功・失敗」などの共通パターンを扱うとき

Rustの `Option<T>` や `Result<T, E>` がこれに当たります。

* **有効な理由**:
「値があるかもしれないし、ないかもしれない」という概念は、数値だろうがユーザーデータだろうが共通しています。
`Option<T>` と定義することで、 **「中身が何であれ、安全に取り出す」** ためのメソッド（`.unwrap()` や `.is_some()` など）をあらゆる型に対して共通して提供できます。


### 3. アルゴリズムを抽象化するとき

「最大値を求める」「並び替える」「平均を出す」といった計算アルゴリズムを実装するときです。

* **有効な理由**:
例えば「2つの値のうち大きい方を返す」関数を作るとき、ジェネリクスを使えば整数 (`i32`)、浮動小数点 (`f64`)、さらには「日付」や「名前の長さ」など、**比較可能なものであれば何にでも**同じ関数を適用できます。


### 逆に、いつ使わないべきか？

ジェネリクスは強力ですが、 **「その型固有の機能」をガッツリ使う場合** は、ジェネリクスを使わずに具体的な型で書く方がシンプルです。

* **具体例**: 「特定の構造体の中にある特定のフィールドを書き換える」だけの関数なら、ジェネリクスにする必要はありません。

## 実装の方法

Rustのジェネリクスを実装する際は、 **「どこで型を宣言し、どこでその型を使うか」** というルールを理解することが重要です。

主に **「構造体」「関数」「implブロック」** の3つの場面での実装方法を詳しく解説します。


### 1. 構造体での実装

構造体名の直後に `<T>` を書くことで、その構造体の中で自由な型 `T` を使えるようになります。

```rust
// T という「型引数」を定義
struct Container<T> {
    value: T,
    id: u32, // ジェネリックでない通常の型も混ぜてOK
}

```

* **ポイント**: `T` は慣習的な名前です。複数の型が必要な場合は `<T, U>` のようにカンマで区切ります。


### 2. 関数での実装

関数名の直後に `<T>` を書きます。これにより、引数や戻り値に `T` を使うことができます。

```rust
// 関数の定義
fn wrap_in_vec<T>(item: T) -> Vec<T> {
    vec![item] // どんな型でも受け取って、その型のVecに入れて返す
}

// 呼び出し時
let numbers = wrap_in_vec(10);      // T は i32 と推論される
let strings = wrap_in_vec("Rust");  // T は &str と推論される

```


### 3. `impl` ブロックでの実装（ここが間違いやすい！）

ジェネリックな構造体にメソッドを追加する場合、**`impl` の直後にも `<T>` が必要**です。

```rust
impl<T> Container<T> {
    // コンストラクタ
    fn new(value: T) -> Self {
        Self { value, id: 0 }
    }

    // 値の参照を返すメソッド
    fn get_value(&self) -> &T {
        &self.value
    }
}

```

> **なぜ `impl<T>` と2回書くのか？**
> `impl<T>` の `<T>` は「これから `T` というジェネリック型を使いますよ」という**宣言**です。
> 続く `Container<T>` は「その `T` を使った `Container` に対して実装しますよ」という**対象の指定**です。


### 4. 応用：特定の型だけに実装する

ジェネリクスの面白いところは、 **「特定の型のときだけ使えるメソッド」** を作れる点です。この場合、`impl` の後ろに `<T>` は書きません。

```rust
// f64（浮動小数点数）の Container だけが持てるメソッド
impl Container<f64> {
    fn absolute_value(&self) -> f64 {
        self.value.abs()
    }
}

```

### 5. トレイト境界（型の制約）の実装

「どんな型でもいい」と言いつつ、「表示ができる型であってほしい」「比較ができる型であってほしい」といった制限をかけることができます。これを**トレイト境界**と呼びます。

```rust
use std::fmt::Display;

// T は Display トレイトを実装している（表示可能である）必要がある
fn print_item<T: Display>(item: T) {
    println!("{}", item);
}

```

### 実装のまとめ

| 実装対象 | 書き方 | 意味 |
| --- | --- | --- |
| **構造体** | `struct Name<T> { ... }` | 構造体内部のフィールドで `T` を使う宣言 |
| **関数** | `fn name<T>(arg: T) { ... }` | 引数や戻り値で `T` を使う宣言 |
| **全般実装** | `impl<T> Name<T> { ... }` | すべての `T` に対してメソッドを定義 |
| **特定実装** | `impl Name<f64> { ... }` | `f64` の時だけメソッドを定義 |

#### コンパイルの仕組み（単一化）

Rustのジェネリクスは、ビルド時に**実際に使われている型ごとに専用のコードを自動生成**します（Monomorphization）。
`Container<i32>` 用の機械語と `Container<String>` 用の機械語が別々に作られるため、実行速度は具体的な型で書いたときと全く同じ、**最高速**で動作します。





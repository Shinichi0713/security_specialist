# Rustにおけるマクロ

## まずマクロという言葉

「マクロ（Macro）」という言葉は、ギリシャ語の $\mu\alpha\kappa\rho\acute{o}\varsigma$（*makros*、「大きい」「長い」の意味）に由来し、主に**「巨視的な」「包括的な」「大規模な」**といった意味合いで用いられます。

文脈によって具体的な意味が異なりますが、最も一般的な2つの分野での意味を解説します。

## コンピュータサイエンス・プログラミングにおけるマクロ

コンピュータの文脈では、マクロは「一連の操作を自動化するための小さなプログラム」を意味します。

### 定義

* **操作の記録と再現:** ユーザーが一連のキーボード操作やマウスクリックなどの手順を実行し、それを記録（定義）します。
* **自動化:** 記録された手順全体を、たった一つのコマンド（キーボードショートカットなど）で**一括実行**できるようにしたものです。
* **用途:** **繰り返しの多い定型作業**（例: テキストの置換、データの整形、レポートの自動作成）を効率化するために用いられます。

### 具体例

* **Microsoft Excel/Word (VBA):** 最も一般的な例です。VBA（Visual Basic for Applications）を用いて、セル操作や文書作成を自動化します。
* **C言語のマクロ:** プリプロセッサ（コンパイル前の処理系）によって、コード中の特定の文字列を別の文字列に置換する機能です。これは主に定数定義や簡単な関数置換に使われます。

## Rustマクロの基本概念

Rustにおける「マクロ」は、プログラミング言語Rustに特有の**コード生成**メカニズムであり、**メタプログラミング**を実現するための強力な機能です。
これは、C言語のシンプルなテキスト置換マクロよりもはるかに強力で、言語の構文レベルで動作し、**コンパイル時**にコードを生成・変更します。

### 1. 構文拡張としてのマクロ

Rustのマクロは、既存のRustの構文を拡張し、新しい構文構造を定義する能力を持っています。マクロ呼び出しは、他の関数呼び出しと区別するために、関数名（マクロ名）の後に**感嘆符 (`!`)** を付けて記述します。

* **例:** `println!("Hello!");`, `vec![1, 2, 3]`

### 2. 衛生的マクロ vs 非衛生的マクロ

Rustのマクロは、その動作原理から大きく二つのカテゴリに分類されます。

#### 🔹 衛生的マクロ (`macro_rules!`)

これがRustで最も一般的に使用されるマクロです。

* **特徴:** マクロ内で定義された変数が、マクロの呼び出し元のスコープと**衝突しない**ように保証されます（衛生的）。安全性が高く、予測可能なコード生成が可能です。
* **用途:** 繰り返し処理の簡略化や、特定のパターンを持つコードブロックの生成。
* **例:** `vec!` マクロ（要素のリストから `Vec<T>` を構築）

#### 🔹 手続きマクロ (Procedural Macros)

より複雑なコード生成や、言語の属性（アトリビュート）を操作するために使用されます。Rustコード自体を操作するRustコードを書く必要があります。

| 種類                          | 記述方法               | 用途                                                                                                                  |
| :---------------------------- | :--------------------- | :-------------------------------------------------------------------------------------------------------------------- |
| **カスタム `derive`** | `#[derive(MyTrait)]` | 構造体や列挙型に対して、自動的にトレイト（Trait）を実装するコードを生成します。最も一般的。                           |
| **属性マクロ**          | `#[route("/")]`      | 関数やモジュール全体にカスタムの属性を適用し、それらのコードを変更します。（例：Webフレームワークのルーティング設定） |
| **関数状マクロ**        | `my_macro!(...)`     | 呼び出し元がどのような引数を渡しても、それに基づいてカスタムなコードを生成します。                                    |

## マクロを使うメリット

1. **DRY (Don't Repeat Yourself) 原則の遵守:** 似たような構造のコードを何度も手書きする代わりに、マクロで抽象化し、コードの重複を防ぎます。
2. **型安全性:** マクロの展開（コード生成）はコンパイル時に行われるため、生成されたコードの型エラーもコンパイル時に検出されます。C言語のような実行時エラーのリスクが低いです。
3. **ドメイン固有言語 (DSL) の構築:** 言語の構文を拡張し、特定の用途に特化した、より直感的で読みやすい独自の構文を定義できます。

### マクロと関数の違い

マクロと関数は似ていますが、決定的な違いがあります。

| 特徴                     | マクロ                                  | 関数                             |
| :----------------------- | :-------------------------------------- | :------------------------------- |
| **実行タイミング** | **コンパイル時**にコード生成/置換 | **実行時**に処理           |
| **引数**           | トークンツリー（抽象的なコード片）      | 値、参照、型                     |
| **多重定義**       | 構文パターンマッチングで実現            | シグネチャ（引数の型と数）で実現 |
| **型情報**         | 処理する段階では**限定的**        | 厳密な型チェックが行われる       |

## マクロの実装

Rustのマクロには、主に**衛生的マクロ (`macro_rules!`)** と**手続きマクロ (Procedural Macros)** の2種類があります。

最も基本的な衛生的マクロの例と、広く使われる手続きマクロ（`derive`）の使用例を以下に示します。

### 1. 衛生的マクロ (`macro_rules!`) の実装例

衛生的マクロは、指定された**パターン**に一致する構文を受け取り、それを別のRustコードに展開します。

__例: `vec!` マクロの単純化版__

要素を列挙するだけで新しい `Vec` を生成するマクロを実装します。

```rust
// macro_rules! でマクロを定義し、マクロ名に感嘆符(!)を付けます。
macro_rules! easy_vec {
    // パターン: () -> 空のベクタを生成
    () => {
        Vec::new()
    };

    // パターン: ($x:expr) -> 要素を一つ持つベクタを生成
    // $x:expr は「任意のRustの式」をキャプチャすることを意味します。
    ($x:expr) => {
        {
            let mut temp_vec = Vec::new();
            temp_vec.push($x);
            temp_vec
        }
    };

    // パターン: ($x:expr, $y:expr, ...) -> 複数の要素を持つベクタを生成
    // $x:expr の後に ,$y:expr とカンマ区切りで0回以上繰り返すことを意味します。
    ($($element:expr),*) => {
        {
            let mut temp_vec = Vec::new();
            // 繰り返し (Repetition) の構文
            $(
                temp_vec.push($element);
            )*
            temp_vec
        }
    };
}

fn main() {
    // 呼び出し例 1: 空のベクタ
    let v1: Vec<i32> = easy_vec!();
    println!("v1: {:?}", v1); // 出力: v1: []

    // 呼び出し例 2: 要素を一つ
    let v2 = easy_vec!(10);
    println!("v2: {:?}", v2); // 出力: v2: [10]

    // 呼び出し例 3: 複数の要素 (マクロ展開後のコードが実行される)
    // 展開後: let v3 = { let mut temp_vec = Vec::new(); temp_vec.push(1); temp_vec.push(2); temp_vec };
    let v3 = easy_vec!(1, 2, 3 + 4, 8);
    println!("v3: {:?}", v3); // 出力: v3: [1, 2, 7, 8]
}
```

__動作のポイント__

* **パターンマッチング:** マクロは渡された引数（トークン）のパターンを上から順に照合し、最初の一致したパターンに対応するコードを生成します。
* **マクロ変数:** `$x:expr` のように、`$` を付けた識別子で引数をキャプチャし、その後にコロンで**フラグメント識別子**（この例では `expr` = 式）を指定します。
* **繰り返し (`$()`):** `$($element:expr),*` の構文は、要素がカンマ区切り (`,`) で0回以上 (`*`) 繰り返されるパターンに一致することを示します。

### 2. 手続きマクロ (`derive`) の実装例（使用方法）

手続きマクロはより複雑ですが、Rustのエコシステムでは、**カスタム `derive`** の形で最も頻繁に使用されます。これは、トレイトの実装を自動化するために使われます。

__例: `Serialize` トレイトの自動実装__

Web APIや設定ファイルでよく使われるデータ構造を扱うために、`serde` クレートの `Serialize` トレイトを自動実装する例です。

**前提:** このコードを実行するには、`Cargo.toml` に以下の依存関係を追加する必要があります。

```toml
[dependencies]
# データ構造をシリアライズ/デシリアライズするために必要
serde = { version = "1.0", features = ["derive"] } 
serde_json = "1.0" # JSON形式に変換するために使用
```

**Rustコード:**

```rust
use serde::Serialize;
use serde_json; // JSON形式に変換するライブラリ

// 構造体に対して、#[derive(Serialize)] を付けるだけで
// Serializeトレイトの必要なメソッドが自動で実装されます。
#[derive(Serialize, Debug)]
struct User {
    id: u32,
    username: String,
    is_active: bool,
}

fn main() {
    let user = User {
        id: 101,
        username: String::from("Rustacean"),
        is_active: true,
    };

    // Serializeマクロによって自動実装された to_string メソッドを使用して
    // 構造体をJSON形式の文字列に変換できます。
    match serde_json::to_string(&user) {
        Ok(json_string) => {
            println!("User JSON: {}", json_string);
            // 出力: User JSON: {"id":101,"username":"Rustacean","is_active":true}
        }
        Err(e) => {
            eprintln!("JSON変換エラー: {}", e);
        }
    }
}
```

### 動作のポイント

* `#[derive(Serialize)]` が手続きマクロです。
* コンパイラは `#[derive(Serialize)]` を見つけると、`User` 構造体の定義を読み込み、**コンパイル時**に `Serialize` トレイトのコードブロックを自動で生成し、構造体に注入します。
* ユーザーは煩雑なトレイト実装コードを手書きする必要がなく、コードが大幅に簡潔になります。


## !の意味
Rustにおける `!` の記号は、文脈によって複数の意味を持ちますが、最も頻繁に見かけるのは**マクロの呼び出し**を意味するものです。

### 1\. 📢 マクロの呼び出し (最も一般的)

Rustで関数を呼び出すときは名前の後に括弧 `()` をつけますが、**マクロ**を呼び出すときは、名前の後に感嘆符 `!` と括弧をつけます。

**書式:** `マクロ名!` + `(引数)` または `{引数}` または `[引数]`

#### 例

  * **`println!`**: 最もよく使われるマクロで、フォーマットされた文字列を標準出力に出力します。
    ```rust
    println!("Hello, world!");
    ```
  * **`vec!`**: ベクタ（動的配列）を簡単に初期化するためのマクロです。
    ```rust
    let numbers = vec![1, 2, 3];
    ```
  * **`assert_eq!`**: 二つの値が等しいかどうかをテストするマクロです。
    ```rust
    assert_eq!(2 + 2, 4);
    ```

#### 🔑 マクロと関数の違い

マクロは、コンパイル時に実行される**コードを生成する**仕組み（メタプログラミング）であり、通常の関数とは根本的に異なります。

| 特徴 | マクロ (`!`) | 関数 (なし) |
| :--- | :--- | :--- |
| **実行タイミング** | コンパイル時 | 実行時 |
| **引数** | 可変長、型付け前のコード断片も可能 | 固定数、厳密に型付けされた値 |
| **役割** | ボイラープレートの削減、新しい文法を定義 | 実行時ロジック、データ処理 |



### 2\. 🛑 Never Type（戻り値の型）

`!` は、関数の戻り値の型として使われることもあります。これは **Never Type**（ネバー型）と呼ばれ、**この関数が戻ることは決してない**ことを示します。

#### 例

この関数は、プログラムを停止させるため、呼び出し元に制御を戻しません。

```rust
fn exit_program() -> ! {
    // パニックを起こす
    panic!("致命的なエラーが発生しました"); 
    
    // または、無限ループ
    // loop {}
}
```

#### 🔑 用途

  * **`panic!` マクロ:** システムに回復不能なエラーが発生したときに使われます。
  * **無限ループ:** 意図的に終了しないことを示すため (`loop { ... }`)。

`!` は、コンパイラに対して「この関数を呼び出した後のコードは到達不能である」ことを明確に伝えます。


### 3\. 🛡️ 生ポインタの安全性解除 (unsafe)

稀なケースですが、Rustの**unsafeブロック**内で生ポインタ (`*const T` や `*mut T`) を扱う際、参照外し（デリファレンス）を行うために `*` ではなく `!` を使用する場合があります。ただし、これは非常に限定的で低レベルな使用法です。

**要約すると、Rustコードで `!` を見かけたら、それは**マクロを呼び出している**と考えるのが**99%**正しいです。**



## `print_vars!` マクロ

このマクロは、渡された変数名とその値を自動的に整形して表示します。

### コード (`main.rs`)

**Rust**

```
// -----------------------------------------------------
// 1. 宣言的マクロの定義
// -----------------------------------------------------
// macro_rules! でマクロ名(print_vars)と定義を開始します。
macro_rules! print_vars {
    // 括弧内のパターンにマッチしたときに実行するコードを記述します。
    // $() は繰り返し構文で、,(コンマ) で区切られた一つ以上の式($e)を受け取ります。
    // $e:expr は、マッチ対象が「式」であることを示します。
    ($($e:expr),*) => {
        // {} の中のコードが、マクロが展開された後に実行されるコードです。
        // $(...) は、パターンでマッチした繰り返し部分に対応します。
        // $e を文字列化して、その後に評価した $e の値を出力します。
        $(
            println!("{}: {:?}", stringify!($e), $e);
        )*
    };
}


// -----------------------------------------------------
// 2. 使用例
// -----------------------------------------------------
fn main() {
    let a = 10;
    let b = 5;
    let name = "Alice";

    println!("--- print_vars! マクロの実行 ---");
  
    // 複数の変数や式をコンマで区切って渡す
    print_vars!(a, b, a * b, name.len(), name);
  
    println!("--------------------------------");
  
    // マクロはブロックや関数呼び出しも展開できます
    let result = {
        let x = 20;
        x + 3
    };
    print_vars!(result, result - 1);
}
```

### 実行結果

```
--- print_vars! マクロの実行 ---
a: 10
b: 5
a * b: 50
name.len(): 5
name: "Alice"
--------------------------------
result: 23
result - 1: 22
```

### 🔑 解説

#### 1. パターンマッチング (`($($e:expr),*)`)

* `$e:expr`: マッチングルールの一つで、「`$e` という名前で**式**にマッチさせる」という意味です。
* `$($e:expr),*`: これは、`$e:expr` がコンマ (`,`) で区切られて**ゼロ回以上**繰り返されるパターンにマッチします。

#### 2. メタプログラミングの機能

* `$e`: マッチした**式そのもの**が、展開後のコードにそのまま挿入され、Rustのコンパイル時に評価されます。
* `stringify!($e)`: マクロ専用の機能で、式 `$e` を評価するのではなく、その式の **文字列表現** （つまりソースコードに書かれたとおりの変数名や式）に変換します。
  * 例: `stringify!(a * b)` は `"a * b"` という文字列になります。

このマクロのおかげで、デバッグ時などに、`println!("a = {}", a);` のように何度も変数を手動で記述しなくても、コンパイラが自動で文字列化と値の出力を生成してくれます。



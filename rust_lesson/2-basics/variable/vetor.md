Rustの**ベクトル（`Vec<T>`）**は、標準ライブラリで提供される「サイズ変更が可能な配列」のようなデータ構造です。

Rustプログラミングにおいて、最も頻繁に使われるコレクション（データの集まり）の一つです。

---

## 💡 ベクトルの主な特徴

### 1. 動的なサイズ変更

通常の配列（例: `[i32; 3]`）は作成時にサイズを決め、後から変えることはできません。しかし、ベクトルは実行中に要素を自由に追加したり削除したりできます。

### 2. ヒープ領域にデータを格納

ベクトルの実データは**ヒープ**と呼ばれるメモリ領域に置かれます。そのため、コンパイル時にデータの個数が決まっていなくても扱うことができます。

### 3. 同一型の保持

一つのベクトルに入れられるのは、**すべて同じ型**の要素だけです。例えば「整数だけのベクトル」や「文字列だけのベクトル」になります。

---

## 🏗️ メモリ上の構造

ベクトルは内部的に、以下の3つの情報を持つ小さな構造体（スタック上に配置）で管理されています。

* **ポインタ (Pointer):** ヒープ上のデータが置かれている場所を指します。
* **長さ (Length):** 現在、実際に格納されている要素の数。
* **容量 (Capacity):** ヒープ上に確保されているメモリの総量（これを超えると再確保が発生します）。

---

## 🛠️ 基本的な使い方

**Rust**

```
fn main() {
    // 1. マクロを使って作成 (型推論で Vec<i32> になる)
    let mut v = vec![1, 2, 3];

    // 2. 要素の追加
    v.push(4);
    v.push(5);

    // 3. 要素へのアクセス
    let third: &i32 = &v[2]; // インデックスは0から
    println!("3番目の要素: {}", third);

    // 4. 安全なアクセス (.get は Option を返す)
    match v.get(10) {
        Some(x) => println!("値があります: {}", x),
        None => println!("範囲外です"),
    }

    // 5. 要素の削除
    v.pop(); // 最後の要素(5)を削除
}
```

---

## 🏎️ ベクトルのパフォーマンスについて

* **末尾への追加 (`push`):** 非常に高速です（計算量はならし **$O(1)$**）。
* **ランダムアクセス:** 添字によるアクセス（`v[i]`）は一瞬です。
* **中間への挿入・削除:** それ以降の要素をすべてずらす必要があるため、要素数が多いと少し時間がかかります。

---

## 📊 配列 (Array) との比較

| **特徴**       | **配列 ([T; N])** | **ベクトル (Vec`<T>`)**    |
| -------------------- | ----------------------- | ---------------------------------- |
| **サイズ**     | 固定（不変）            | **可変**                     |
| **メモリ場所** | スタック（高速）        | ヒープ                             |
| **用途**       | 個数が決まっている時    | **個数が不明な時・変わる時** |

Rustのベクトルについて、他に「所有権が絡んだ時の挙動」や「効率的な初期化の方法」など、気になる部分はありますか？



ベクトルの用途は非常に幅広く、**「データの個数が事前に決まっていない場合」 **や** 「データを順番に並べて管理したい場合」**のほとんどで第一選択となります。

具体的な利用シーンをいくつか挙げます。

---

## 🛠️ ベクトルの主な用途

### 1. ユーザー入力やファイルデータの読み込み

プログラムを実行するまで、ユーザーが何文字入力するか、あるいはファイルに何行のデータがあるかは分かりません。

* **例:** ログファイルの各行を読み込んで、エラーが含まれる行だけをリストに保存する。
* **例:** アンケートフォームで入力された回答のリストを保持する。

### 2. 動的なリストの管理（Todoリストや買い物かご）

要素が増えたり減ったりするアプリケーションの「状態」を管理するのに最適です。

* **例:** ショッピングサイトの「カートに入れた商品」の管理。
* **例:** ゲームにおける「現在画面内にいる敵キャラクター」の一覧。

### 3. スタック（LIFO: 後入れ先出し）としての利用

ベクトルは `push`（末尾に追加）と `pop`（末尾から取り出す）が非常に高速なため、**スタック**というデータ構造として使われます。

* **例:** ブラウザの「戻る」ボタンの履歴管理。
* **例:** 計算機プログラムでの数式の解析や、再帰処理のシミュレーション。

### 4. データのバッファ（一時保存）

通信やファイル操作において、データを一定量溜めてから処理する場合に使われます。

* **例:** ネットワーク経由で受信したバイナリデータ（`Vec<u8>`）を一時的に保持する。
* **例:** 画像処理で、ピクセルデータの並びを保持する。

---

## 🏗️ メモリ上のイメージ

ベクトルがどのようにデータを保持しているかを知ると、なぜ「可変」なのかが分かりやすくなります。

* **ポインタ:** ヒープ領域のデータの開始地点を指します。
* **長さ (len):** 今、実際にデータが入っている個数です。
* **容量 (cap):** あとどれくらいデータを入れられるかの限界値です。足りなくなると、自動的に広い場所へ引っ越して「容量」を増やします。

---

## 💡 いつベクトル「以外」を使うべきか？

ベクトルは万能ですが、以下の場合は他のデータ構造の方が適していることがあります。

* **データの重複を許したくない場合:** `HashSet<T>`
* **「キー」と「値」のペアで管理したい場合（辞書形式）:** `HashMap<K, V>`
* **データの追加・削除が「先頭」で頻繁に起こる場合:** `VecDeque<T>`（ベクトルは先頭の操作が苦手です）
* **サイズが絶対に変わらず、スタックで高速に処理したい場合:** 配列 `[T; N]`

---

### 次のステップへの提案

「ベクトルの要素を1つずつ取り出して処理する（ループ）」方法や、「特定の条件で要素をフィルタリングする」方法についてコード例を見てみますか？

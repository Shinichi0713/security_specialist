Rustの構造体についてまとめます。

Rustにおける構造体は、関連するデータをひとまとめにして扱うためのデータ構造です。
C言語やC++の構造体と似ていますが、Rustの構造体はより強力で柔軟な機能を持っています。

## 概要
ざっとリストアップします。

* **データの集約:** 複数の異なる型のデータを、意味のあるまとまりとして扱うことができます。
* **メソッドの定義:** 構造体に対してメソッドを定義することで、構造体が持つデータに対する操作をカプセル化できます。
* **トレイトの実装:** 構造体にトレイトを実装することで、共通のインターフェースを持つ複数の構造体を統一的に扱うことができます。
* **ジェネリクス:** ジェネリクスを使用することで、様々な型のデータを扱うことができる汎用的な構造体を定義できます。

## メリット
Rustで構造体を使うメリットは以下の通りです。
ほぼ、通常のclassと同じ。

もし、差別化になる要素を知りたいという方はこの下の方で説明させて頂いています。

* **コードの可読性向上:** 関連するデータを構造体にまとめることで、コードの意図が明確になり、可読性が向上します。
* **保守性の向上:** データとメソッドをカプセル化することで、データ構造の変更が他に与える影響を最小限に抑え、保守性を向上させることができます。
* **再利用性の向上:** 構造体やトレイトを再利用することで、コードの重複を減らし、開発効率を向上させることができます。
* **安全性:** Rustの所有権システムや借用規則と組み合わせることで、メモリ安全性やデータ競合などの問題を防ぐことができます。

### 補足

Rustには、構造体以外にも`Enum`や`Tuple`といったデータ構造があります。それぞれのデータ構造には特徴があり、適切なものを選択することで、より効果的にコードを記述することができます。

## 実装

続いてRustにおける構造体の実装法について説明します。

### Rustの構造体：実装の3ステップ

Rustで構造体を使う際は、一般的に **「定義」「インスタンス化」「動作（メソッド）の実装」** という手順を踏みます。

__1. 構造体を定義する（設計図を作る）__

まず、どのようなデータを持たせるかを決めます。`struct`キーワードを使い、フィールド名とその型を指定します。

```rust
// 「本」を表現する構造体の定義
struct Book {
    title: String,
    author: String,
    pages: u32,
    is_available: bool,
}

```

__2. 構造体をインスタンス化する（実体を作る）__

定義した設計図をもとに、実際のデータを作成します。

```rust
fn main() {
    // 構造体のインスタンスを作成
    let my_book = Book {
        title: String::from("Rust入門"),
        author: String::from("Rustacean"),
        pages: 350,
        is_available: true,
    };

    // ドット演算子 (.) でデータにアクセスできる
    println!("書名: {}", my_book.title);
}

```

__3. メソッドを実装する（動作を与える）__

ここがクラス（class）との大きな違いです。構造体の定義の外に `impl` ブロックを作り、その中で関数（メソッド）を書きます。

* **メソッド**: `&self` を引数に取り、特定のインスタンスに対して実行するもの。
* **関連関数**: `self` を取らず、`Book::new()` のように呼び出すもの（他言語のスタティックメソッドに近い）。

```rust
impl Book {
    // 関連関数：新しい本を作る「コンストラクタ」のような役割
    fn new(title: &str, author: &str, pages: u32) -> Self {
        Self {
            title: title.to_string(),
            author: author.to_string(),
            pages,
            is_available: true,
        }
    }

    // メソッド：本の概要を表示する動作
    fn print_summary(&self) {
        println!("『{}』（{}著、{}ページ）", self.title, self.author, self.pages);
    }
}

// 使い方
fn main() {
    let book2 = Book::new("実践Rust", "エンジニアA", 420);
    book2.print_summary(); // メソッドの呼び出し
}

```


## classとの違い

Rustの構造体 (struct) と、C++やJava、Pythonなどのオブジェクト指向言語におけるクラス (class) は、どちらもデータとその操作をまとめるための仕組みですが、その設計思想や機能にはいくつかの重要な違いがあります。

**類似点:**

* **データと関数のカプセル化:** どちらも、関連するデータ (フィールド/メンバ変数) とそれらを操作する関数 (メソッド/メンバ関数) をひとまとめにすることができます。
* **インスタンス化:** 定義に基づいて、具体的なデータを持つインスタンス (オブジェクト) を生成できます。

**相違点:**

1. **継承:**
* **クラス:** 継承をサポートしており、既存のクラスを基に新しいクラスを作成し、機能やデータを引き継いだり拡張したりできます。
* **構造体:** 継承を直接サポートしていません。代わりに、トレイト (trait) を使って共通の振る舞いを定義し、複数の構造体に実装させることで、継承に近いことを実現します。


2. **メソッド定義:**
* **クラス:** メソッド定義はクラス定義の中に含まれます。
* **構造体:** メソッド定義は `impl` ブロックを使って構造体定義の外で行われます。


3. **所有権と借用:**
* **クラス:** メモリ管理はガベージコレクションや参照カウントなどで行われることが多く、所有権や借用の概念は意識しにくい場合があります。
* **構造体:** Rustの所有権と借用システムが適用され、メモリ管理が厳密に行われます。これにより、メモリリークやデータ競合などの問題を防ぐことができます。


4. **データレイアウト:**
* **クラス:** フィールドのメモリ上の配置は言語やコンパイラによって異なる場合があります。
* **構造体:** デフォルトではフィールドは定義順に配置されますが、`repr(C)` などのアトリビュートを使って明示的に指定することもできます。


5. **用途:**
* **クラス:** オブジェクト指向プログラミングにおいて、データと振る舞いをまとめるための基本的な構成要素として使われます。
* **構造体:** データ構造を定義したり、メソッドをカプセル化したりするために使われます。Rustでは、オブジェクト指向的な設計よりも、データ構造と関数を組み合わせた関数型プログラミング的な設計が好まれる傾向があります。


## 構造体を使うべき場面

Rustの構造体（`struct`）は、単にデータをまとめるだけでなく、 **「データの整合性を保ち、プログラムの複雑さを制御する」** ために非常に効果的です。

具体的にどのような場面で使うのが効果的なのか、3つの主要なシーンとその理由を解説します。


### 1. 複数の関連する情報を「一つの概念」として扱うとき

**例：ユーザー情報、商品の座標、センサーの計測データなど**

バラバラの変数（`user_name`, `user_email`, `user_age`）として管理するのではなく、一つの「User構造体」にまとめる場面です。

* **理由（可読性と保守性）**:
関数の引数にバラバラと値を渡す必要がなくなり、`fn register(user: User)` のように書けるため、コードがスッキリします。また、「名前とメールアドレスは必ずセットである」という **ドメイン（業務知識）** をコード上で表現できます。


### 2. データの「正しい状態」を強制したいとき

**例：バリデーションが必要な値（メールアドレス、パスワード、年齢など）**

ただの文字列（`String`）として扱うのではなく、特定のルールを守った構造体として定義する場面です。

* **理由（安全性）**:
構造体の「関連関数（`new`関数など）」の中でチェックを行い、不正なデータ（例：マイナスの年齢）を弾くように実装すれば、 **その構造体のインスタンスが存在している＝正しいデータであることが保証される** 状態を作れます。これにより、プログラムの他の場所で何度もチェックを行う手間が省けます。


### 3. データに「特定の振る舞い（メソッド）」を持たせたいとき

**例：図形の面積計算、ネットワーク接続の管理、ゲームのキャラクター操作など**

データそのものだけでなく、そのデータを使って「何ができるか」をカプセル化したい場面です。

* **理由（カプセル化）**:
`impl`ブロックでメソッドを定義することで、内部のデータ構造（どうやって計算しているか）を隠したまま、利用者には便利な機能だけを提供できます。
例えば、`Rectangle`構造体に`.area()`メソッドを持たせれば、利用者は幅や高さの計算式を知らなくても「面積を出す」という目的を達成できます。




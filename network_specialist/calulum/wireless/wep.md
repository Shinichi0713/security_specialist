WEP（Wired Equivalent Privacy）は、その名の通り **「無線LANにおいて、有線（Wired）と同等（Equivalent）のプライバシー（Privacy）を実現すること」** を目的に作られた、世界初の無線LANセキュリティ規格です。

1997年に登場したIEEE 802.11規格の標準的な暗号化方式として採用されました。

### WEPが作られた主な理由

無線通信は、有線ケーブルと違って「電波が届く範囲であれば誰でも通信を傍受できてしまう」という根本的な弱点があります。これを解決するために、以下の3つの役割を果たすべく作られました。

#### 1. データの暗号化（機密性の確保）

通信内容を暗号化し、たとえ電波を傍受されても、第三者に内容（メールやパスワードなど）を読み取られないようにするためです。

#### 2. アクセス制御（認証）

「WEPキー（パスワード）」を知っている人だけがネットワークに接続できるようにし、部外者のタダ乗りや侵入を防ぐためです。

#### 3. データの改ざん検知（整合性の確保）

通信の途中でデータが書き換えられていないかをチェックする仕組みを入れ、正しいデータが届くことを保証するためです。


### WEPの仕組みと「弱点」

WEPは「RC4」という暗号化アルゴリズム(※1)を使用していました。しかし、現在では **「非常に脆弱（弱い）」** であることが知られており、絶対に使用してはいけない規格とされています。

なぜ「有線同等」を目指したのに失敗したのでしょうか？

* **短すぎるIV（初期化ベクトル）:** 暗号化のたびに変える「IV」という値が24ビットと短すぎたため、通信量が多いとすぐに同じ値が使い回されてしまいました。
* **解読の容易さ:** 現在のPCスペックであれば、数分、あるいは数秒でパスワードを解析できてしまいます。
* **鍵が固定:** 一度設定したWEPキーを自動で更新する仕組みがなかったため、一度漏洩するとずっと危険な状態が続きます。

>__※1：暗号アルゴリズム__  
>データを一定のルールに従って、意味のわからない文字列（暗号文）に書き換えるための計算手順（数式）のことです。
>1. 暗号化の基本サイクル  
>暗号化アルゴリズムは、以下の要素で構成されます。
>- 平文（ひらぶん）: そのまま読める元のデータ。
>- アルゴリズム: データをかき混ぜるための「複雑な手順書」。
>- 鍵（Key）: 手順書を動かすための「特別なパスワード（数字の羅列）」。
>- 暗号文: アルゴリズムと鍵によって変換された、第三者には解読不能なデータ。
>2. 暗号化アルゴリズムの2大方式  
>暗号化アルゴリズムは、**「鍵をどう扱うか」**によって大きく2つのタイプに分けられます。
>__① 共通鍵暗号方式（対称暗号）__  
送信者と受信者が **「同じ鍵」** を使って、暗号化と復号（元に戻すこと）を行う方式です。  
>例: 一つの南京錠に対して、同じ鍵を2人が持っている状態。  
>代表的なアルゴリズム: AES（現在の世界標準。WPA2などでも使用）  
>特徴: 処理が非常に高速。ただし、鍵を相手にどうやって安全に渡すかが課題。  
>__② 公開鍵暗号方式（非対称暗号）__  
>誰にでも渡していい **「公開鍵」で暗号化し、自分だけが持つ「秘密鍵」** で復号する方式です。  
>例: 誰でも閉められる（が、開けられない）「投函口付きの金庫」を公開し、中身は自分の合鍵でしか取り出せない状態。  
>代表的なアルゴリズム: RSA、楕円曲線暗号（ECC）  
>特徴: 鍵の受け渡しが安全。ただし、計算が非常に複雑で処理が重い。



### その後の進化

WEPの脆弱性が明らかになったため、より強力な後継規格が登場しました。

1. **WPA:** WEPの弱点を急遽補うために作られた暫定規格。
2. **WPA2:** 強固な暗号化アルゴリズム（AES）を採用した、長らく標準だった規格。
3. **WPA3:** 現在の最新規格。より高度な保護と、パスワード推測攻撃への耐性を備えています。


### まとめ

WEPは **「電波という筒抜けの媒体に、有線のような安心感（鍵）を持たせるため」** に誕生しました。しかし、暗号としての寿命は短く、現在は「セキュリティの歴史における教訓」のような存在になっています。

先ほど学んだ「物理層（PLCP/PMD）」の上にある **「データリンク層」** の一部として、このWEPなどの暗号化処理が動いています。

## RC4
ここからが本題かもしれません。
廃止された暗号化アルゴリズムであるRC4について調べてみました。

### 概要
RC4（Rivest Cipher 4）は、1987年にロナルド・リベストによって開発された **「ストリーム暗号」** と呼ばれる種類の暗号化アルゴリズムです。

かつては、無線LANの**WEP**や、インターネット通信の**SSL/TLS**などで世界中で最も広く使われていましたが、現在は致命的な弱点が見つかっており、使用が禁止（非推奨）されています。

### RC4の最大の特徴：ストリーム暗号

暗号化アルゴリズムには大きく分けて2つのタイプがありますが、RC4は**ストリーム暗号**の代表格です。

* **ブロック暗号（AESなど）**: データを一定のサイズ（例：128ビット）ごとに区切って、まとめて暗号化する。
* **ストリーム暗号（RC4）**: データの最小単位（1ビットや1バイト）ごとに、次々と流れるように暗号化する。

**なぜRC4が流行ったのか？**
それは **「圧倒的な速さとシンプルさ」** にあります。複雑な計算を必要としないため、CPUパワーが乏しかった昔のコンピュータやルーターでも、非常に高速に処理ができたのです。

### RC4の仕組み

RC4は、以下の2段階で暗号化を行います。

1. **鍵の拡張**: 短いパスワード（鍵）をもとに、256バイトの内部状態（Sボックス）をかき混ぜて準備します。
2. **キーストリームの生成**: 準備したSボックスから、データと同じ長さの「デタラメな数字の列（疑似乱数）」を次々と生成します。
3. **XOR（排他的論理和）演算**: 実際のデータと、生成した乱数列を「XOR」という計算でガッチャンコさせます。これで暗号文が完成します。


### なぜRC4（WEP）は破られたのか？

RC4自体は数学的に優れた面もありましたが、 **「使い方のルール」** に致命的な欠陥がありました。

#### ① キーストリームの偏り（統計的脆弱性）

RC4が生成する乱数列の最初の数百バイトには、 **「特定の数字が出現しやすい」という微妙な偏り** があることが発見されました。大量の暗号文を集めて統計的に分析すると、元のデータや鍵が推測できてしまうのです。

#### ② 鍵の使い回し問題

ストリーム暗号において、 **「同じ鍵で、同じ乱数列を作って、別のデータを暗号化する」ことは絶対に禁じ手** です。
WEPでは「IV（初期化ベクトル）」という値を使って毎回乱数を変えようとしましたが、IVが短すぎたために、同じ乱数列が何度も発生してしまいました。

> **例え話：**
> 透かしの入った下敷き（乱数）の上に、紙（データ）を置いて文字をなぞると想像してください。同じ下敷きを何度も使い回すと、下敷き側に「よく通る筆跡の跡」が残ってしまい、中身がバレてしまうようなイメージです。


### 現在の立ち位置

* **2015年**: IETF（インターネットの標準化団体）により、TLS通信でのRC4使用が正式に禁止されました。
* **現状**: 最新のブラウザやサーバーではRC4は無効化されており、代わりにブロック暗号の **AES** や、新しいストリーム暗号の **ChaCha20** などが使われています。

### Rustの実装

以下Rustで暗号化アルゴリズムが実装出来ます。

※絶対にwebアプリの暗号化には使わないでください。脆弱性が既知なためです。

```rust
struct Rc4 {
    state: [u8; 256],
    i: usize,
    j: usize,
}

impl Rc4 {
    // 1. KSA (Key-Scheduling Algorithm): 鍵を元に256バイトのSボックスを初期化
    fn new(key: &[u8]) -> Self {
        let mut state = [0u8; 256];
        for i in 0..256 {
            state[i] = i as u8;
        }

        let mut j: usize = 0;
        let key_len = key.len();

        for i in 0..256 {
            // 鍵の値を使いながらSボックスの要素を入れ替える（かき混ぜる）
            j = (j + state[i] as usize + key[key_len > 0].wrapping_add(key[i % key_len]) as usize) % 256;
            state.swap(i, j);
        }

        Rc4 { state, i: 0, j: 0 }
    }

    // 2. PRGA (Pseudo-Random Generation Algorithm): 1バイトずつ乱数を生成
    fn next_byte(&mut self) -> u8 {
        self.i = (self.i + 1) % 256;
        self.j = (self.j + self.state[self.i] as usize) % 256;

        self.state.swap(self.i, self.j);

        let t = (self.state[self.i].wrapping_add(self.state[self.j])) as usize % 256;
        self.state[t]
    }

    // 暗号化/復号化処理 (XOR演算)
    fn apply(&mut self, data: &mut [u8]) {
        for byte in data.iter_mut() {
            // データ1バイトに対して、生成した乱数1バイトをXORする
            *byte ^= self.next_byte();
        }
    }
}

fn main() {
    let key = b"SecretKey"; // 暗号鍵
    let mut data = b"Hello, Rust!".to_owned(); // 平文

    println!("元のデータ: {:?}", String::from_utf8_lossy(&data));

    // 暗号化
    let mut rc4_enc = Rc4::new(key);
    rc4_enc.apply(&mut data);
    println!("暗号化後 (16進数): {:x?}", data);

    // 復号化 (同じ鍵で再度XORすると元に戻る)
    let mut rc4_dec = Rc4::new(key);
    rc4_dec.apply(&mut data);
    println!("復号化後: {:?}", String::from_utf8_lossy(&data));
}
```

ということで今は無きWEPと、WEPに用いられていたRC4についてでした。


